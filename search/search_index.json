{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FastApi Framework","title":"FastAPI Framework"},{"location":"#fastapi-framework","text":"","title":"FastApi Framework"},{"location":"environment/","text":"Environment There are some Environment Variables you should set if you want to use a Database or Redis. Database Name Default Description DB_DRIVER postgresql+asyncpg The Database Driver to use DB_HOST localhost Host of the DB Server DB_PORT 5432 Port of the Database DB_USERNAME postgres Database Username DB_PASSWORD Database Password DB_DATABASE Name of the Database DB_POOL_SIZE 20 Database Connection Pool Size DB_MAX_OVERFLOW 20 Max Pool Size Redis Name Default Description REDIS_HOST localhost Host of the Redis Server REDIS_PORT 63792 Port of the Redis Server JWT Name Default Description JWT_SECRET_KEY Secret Key for JWT Authentication JWT_ALGORITHM HS256 The Algorithm for JWT JWT_ACCESS_TOKEN_EXPIRE_MINUTES 30 Expire time for the Access Token JWT_REFRESH_TOKEN_EXPIRE_MINUTES 360 Expire time for the Refresh Token Modules Name Default Description DISABLED_MODULES Name of Modules too disable The names should seperated by , , , or ; . All Module names are: database redis jwt_auth logger rate_limit Other Name Default Description LOG_LEVEL INFO Log Level e.g. DEBUG , INFO , WARNING or ERROR","title":"Environment"},{"location":"environment/#environment","text":"There are some Environment Variables you should set if you want to use a Database or Redis.","title":"Environment"},{"location":"environment/#database","text":"Name Default Description DB_DRIVER postgresql+asyncpg The Database Driver to use DB_HOST localhost Host of the DB Server DB_PORT 5432 Port of the Database DB_USERNAME postgres Database Username DB_PASSWORD Database Password DB_DATABASE Name of the Database DB_POOL_SIZE 20 Database Connection Pool Size DB_MAX_OVERFLOW 20 Max Pool Size","title":"Database"},{"location":"environment/#redis","text":"Name Default Description REDIS_HOST localhost Host of the Redis Server REDIS_PORT 63792 Port of the Redis Server","title":"Redis"},{"location":"environment/#jwt","text":"Name Default Description JWT_SECRET_KEY Secret Key for JWT Authentication JWT_ALGORITHM HS256 The Algorithm for JWT JWT_ACCESS_TOKEN_EXPIRE_MINUTES 30 Expire time for the Access Token JWT_REFRESH_TOKEN_EXPIRE_MINUTES 360 Expire time for the Refresh Token","title":"JWT"},{"location":"environment/#modules","text":"Name Default Description DISABLED_MODULES Name of Modules too disable The names should seperated by , , , or ; . All Module names are: database redis jwt_auth logger rate_limit","title":"Modules"},{"location":"environment/#other","text":"Name Default Description LOG_LEVEL INFO Log Level e.g. DEBUG , INFO , WARNING or ERROR","title":"Other"},{"location":"config/","text":"Config The Config Module is a simple \"Config Parser\". Example from fastapi_framework import Config , ConfigField class MyConfig ( Config ): name : str = ConfigField () version : str = ConfigField ( \"v1.0\" ) timestamp : int = ConfigField ( name = \"_timestamp\" ) print ( MyConfig . name ) print ( MyConfig . version ) print ( MyConfig . timestamp ) Content of config.yaml : name : My cool Name _timestamp : 123456789 Result: My cool Name v1 123456789 As you can see if the version Config isn't set it will have the default value! You can use another Key for the Config as the Variables name by setting name to the Name Tip Config Fields can have a Type Hint and will get converted to this type Tip You can define CONFIG_PATH to set the Path of the File Tip You can define CONFIG_TYPE to set the File Type e.g. yaml , json and toml","title":"Config"},{"location":"config/#config","text":"The Config Module is a simple \"Config Parser\".","title":"Config"},{"location":"config/#example","text":"from fastapi_framework import Config , ConfigField class MyConfig ( Config ): name : str = ConfigField () version : str = ConfigField ( \"v1.0\" ) timestamp : int = ConfigField ( name = \"_timestamp\" ) print ( MyConfig . name ) print ( MyConfig . version ) print ( MyConfig . timestamp ) Content of config.yaml : name : My cool Name _timestamp : 123456789 Result: My cool Name v1 123456789 As you can see if the version Config isn't set it will have the default value! You can use another Key for the Config as the Variables name by setting name to the Name Tip Config Fields can have a Type Hint and will get converted to this type Tip You can define CONFIG_PATH to set the Path of the File Tip You can define CONFIG_TYPE to set the File Type e.g. yaml , json and toml","title":"Example"},{"location":"database/","text":"Database The Database Module is a Wrapper with asnyc Support for SQLAlchemy . Its based on PyDrocsid's Database Wrapper .","title":"Database"},{"location":"database/#database","text":"The Database Module is a Wrapper with asnyc Support for SQLAlchemy . Its based on PyDrocsid's Database Wrapper .","title":"Database"},{"location":"database/example/","text":"Example from fastapi_framework.database import db , select from fastapi import FastAPI , HTTPException from sqlalchemy import Integer , Column , String from typing import Union app = FastAPI () class User ( db . Base ): __tablename__ = \"users\" id : Union [ Column , int ] = Column ( Integer , primary_key = True ) name : Union [ Column , str ] = Column ( String ( 255 )) @staticmethod async def create ( name : str ) -> \"User\" : row = User ( name = name ) await db . add ( row ) return row @app . get ( \"/users\" ) async def get_users (): return await db . all ( select ( User )) @app . get ( \"/users/ {name} \" ) async def get_users ( name : str ): return await db . all ( select ( User ) . filter_by ( name = name )) @app . post ( \"/users/ {name} \" ) async def add_user ( name : str ) -> User : if await db . exists ( select ( User ) . filter_by ( name = name )): raise HTTPException ( 409 , \"Username already used\" ) user = await User . create ( name ) await db . commit () return user","title":"Example"},{"location":"database/example/#example","text":"from fastapi_framework.database import db , select from fastapi import FastAPI , HTTPException from sqlalchemy import Integer , Column , String from typing import Union app = FastAPI () class User ( db . Base ): __tablename__ = \"users\" id : Union [ Column , int ] = Column ( Integer , primary_key = True ) name : Union [ Column , str ] = Column ( String ( 255 )) @staticmethod async def create ( name : str ) -> \"User\" : row = User ( name = name ) await db . add ( row ) return row @app . get ( \"/users\" ) async def get_users (): return await db . all ( select ( User )) @app . get ( \"/users/ {name} \" ) async def get_users ( name : str ): return await db . all ( select ( User ) . filter_by ( name = name )) @app . post ( \"/users/ {name} \" ) async def add_user ( name : str ) -> User : if await db . exists ( select ( User ) . filter_by ( name = name )): raise HTTPException ( 409 , \"Username already used\" ) user = await User . create ( name ) await db . commit () return user","title":"Example"},{"location":"database/insert_delete_modify/","text":"Insert, Delete and Modify Data Insert Data With db.add you can insert Date into the Database from fastapi_framework.database import db class MyModel ( db . Base ): # The Model Code pass async def main (): obj : MyModel = MyModel ( x = 1 ) await db . add ( obj ) Delete Data With db.delete you can delete Data from your Database from fastapi_framework.database import db , select class MyModel ( db . Base ): # The Model Code pass async def main (): model : MyModel = await select ( MyModel ) . filter_by ( x = 1 ) await db . delete ( model ) Modify Data You can modify Data in your Database by change the Model Class Attribute from fastapi_framework.database import db , select class MyModel ( db . Base ): # The Model Code pass async def main (): model : MyModel = await select ( MyModel ) . filter_by ( x = 1 ) model . x = 1","title":"Insert, Delete and Modify Data"},{"location":"database/insert_delete_modify/#insert-delete-and-modify-data","text":"","title":"Insert, Delete and Modify Data"},{"location":"database/insert_delete_modify/#insert-data","text":"With db.add you can insert Date into the Database from fastapi_framework.database import db class MyModel ( db . Base ): # The Model Code pass async def main (): obj : MyModel = MyModel ( x = 1 ) await db . add ( obj )","title":"Insert Data"},{"location":"database/insert_delete_modify/#delete-data","text":"With db.delete you can delete Data from your Database from fastapi_framework.database import db , select class MyModel ( db . Base ): # The Model Code pass async def main (): model : MyModel = await select ( MyModel ) . filter_by ( x = 1 ) await db . delete ( model )","title":"Delete Data"},{"location":"database/insert_delete_modify/#modify-data","text":"You can modify Data in your Database by change the Model Class Attribute from fastapi_framework.database import db , select class MyModel ( db . Base ): # The Model Code pass async def main (): model : MyModel = await select ( MyModel ) . filter_by ( x = 1 ) model . x = 1","title":"Modify Data"},{"location":"database/models/","text":"Models The Tutorial for SQLAlchemy Models can befound here . A Model class should inherit from fastapi_framework.db.Base To create the Models Async in your Code you could add this async function to your models: from fastapi_framework import db class MyModel ( db . Base ): # your model code @staticmethod async def create ( param : int , param2 : str ) -> \"MyModel\" : row = MyModel ( param = param , param2 = param2 ) await db . add ( row ) return row","title":"Models"},{"location":"database/models/#models","text":"The Tutorial for SQLAlchemy Models can befound here . A Model class should inherit from fastapi_framework.db.Base To create the Models Async in your Code you could add this async function to your models: from fastapi_framework import db class MyModel ( db . Base ): # your model code @staticmethod async def create ( param : int , param2 : str ) -> \"MyModel\" : row = MyModel ( param = param , param2 = param2 ) await db . add ( row ) return row","title":"Models"},{"location":"database/query/","text":"Query Function for Database Query are from fastapi_framework.database import select , filter_by Select from fastapi_framework.database import db , select class MyModel ( db . Base ): # The Model Code pass async def main (): query = select ( MyModel ) # Selects all from the MyModel table Filter By filter_by(Model, criteria) is a shortcut for select(Model).filer_by(criteria) from fastapi_framework.database import db , select , filter_by class MyModel ( db . Base ): # The Model Code pass async def main (): query = filter_by ( MyModel , id = 1 ) # Selects all from the MyModel table where id is 1 # Same here: query = select ( MyModel ) . filter_by ( id = 1 ) Execute Querys Get First Element Returns the first Result for the Query. Could be None from fastapi_framework.database import db , select class MyModel ( db . Base ): # The Model Code pass async def main (): query = select ( MyModel ) # Your Query result : MyModel = await db . first ( query ) Get All Element Returns all results for the query. Could be [] from fastapi_framework.database import db , select class MyModel ( db . Base ): # The Model Code pass async def main (): query = select ( MyModel ) # Your Query result : list [ MyModel ] = await db . all ( query ) Check Exists Checks if data for this query exists from fastapi_framework.database import db , select class MyModel ( db . Base ): # The Model Code pass async def main (): query = select ( MyModel ) # Your Query exists : bool = await db . exists ( query ) Count Results Returns count of matching rows for the query from fastapi_framework.database import db , select class MyModel ( db . Base ): # The Model Code pass async def main (): query = select ( MyModel ) # Your Query count : int = await db . count ( query )","title":"Query"},{"location":"database/query/#query","text":"Function for Database Query are from fastapi_framework.database import select , filter_by","title":"Query"},{"location":"database/query/#select","text":"from fastapi_framework.database import db , select class MyModel ( db . Base ): # The Model Code pass async def main (): query = select ( MyModel ) # Selects all from the MyModel table","title":"Select"},{"location":"database/query/#filter-by","text":"filter_by(Model, criteria) is a shortcut for select(Model).filer_by(criteria) from fastapi_framework.database import db , select , filter_by class MyModel ( db . Base ): # The Model Code pass async def main (): query = filter_by ( MyModel , id = 1 ) # Selects all from the MyModel table where id is 1 # Same here: query = select ( MyModel ) . filter_by ( id = 1 )","title":"Filter By"},{"location":"database/query/#execute-querys","text":"","title":"Execute Querys"},{"location":"database/query/#get-first-element","text":"Returns the first Result for the Query. Could be None from fastapi_framework.database import db , select class MyModel ( db . Base ): # The Model Code pass async def main (): query = select ( MyModel ) # Your Query result : MyModel = await db . first ( query )","title":"Get First Element"},{"location":"database/query/#get-all-element","text":"Returns all results for the query. Could be [] from fastapi_framework.database import db , select class MyModel ( db . Base ): # The Model Code pass async def main (): query = select ( MyModel ) # Your Query result : list [ MyModel ] = await db . all ( query )","title":"Get All Element"},{"location":"database/query/#check-exists","text":"Checks if data for this query exists from fastapi_framework.database import db , select class MyModel ( db . Base ): # The Model Code pass async def main (): query = select ( MyModel ) # Your Query exists : bool = await db . exists ( query )","title":"Check Exists"},{"location":"database/query/#count-results","text":"Returns count of matching rows for the query from fastapi_framework.database import db , select class MyModel ( db . Base ): # The Model Code pass async def main (): query = select ( MyModel ) # Your Query count : int = await db . count ( query )","title":"Count Results"},{"location":"in_memory_backends/api/","text":"Introduction The In Memory Backend API is the interface that can be used for Redis but also for the Custom In Memory Backend.","title":"Introduction"},{"location":"in_memory_backends/api/#introduction","text":"The In Memory Backend API is the interface that can be used for Redis but also for the Custom In Memory Backend.","title":"Introduction"},{"location":"in_memory_backends/api/delete_exists/","text":"Delete and Exists Delete You can Delete Keys with await redis . delete ( \"my_key\" ) Exists You can check if a Key exists await redis . exists ( \"this_exists\" ) # True await redis . exists ( \"this_dont_exists\" ) # False","title":"Delete and Exists"},{"location":"in_memory_backends/api/delete_exists/#delete-and-exists","text":"","title":"Delete and Exists"},{"location":"in_memory_backends/api/delete_exists/#delete","text":"You can Delete Keys with await redis . delete ( \"my_key\" )","title":"Delete"},{"location":"in_memory_backends/api/delete_exists/#exists","text":"You can check if a Key exists await redis . exists ( \"this_exists\" ) # True await redis . exists ( \"this_dont_exists\" ) # False","title":"Exists"},{"location":"in_memory_backends/api/expires/","text":"Expires Set Expire Time You can set the Expire time in Seconds or Milliseconds with await redis . expire ( \"my_key\" , 5 ) # 5 Seconds await redis . pexpire ( \"my_key\" , 1200 ) # 1200 Milliseconds => 1.2 Seconds Get Expire Time You can get the Expire tim of a Key with await redis . ttl ( \"my_key\" ) # 5 await redis . pttl ( \"my_key\" ) # 1200 await redis . pttl ( \"this_key_dont_exists\" ) # -2 await redis . pttl ( \"expired_key\" ) # -1 - TTL Returns the Seconds - PTTL Returns the Milliseconds - If the Key doesn't exists it will return -2 - If the Key is expired it will return -1","title":"Expires"},{"location":"in_memory_backends/api/expires/#expires","text":"","title":"Expires"},{"location":"in_memory_backends/api/expires/#set-expire-time","text":"You can set the Expire time in Seconds or Milliseconds with await redis . expire ( \"my_key\" , 5 ) # 5 Seconds await redis . pexpire ( \"my_key\" , 1200 ) # 1200 Milliseconds => 1.2 Seconds","title":"Set Expire Time"},{"location":"in_memory_backends/api/expires/#get-expire-time","text":"You can get the Expire tim of a Key with await redis . ttl ( \"my_key\" ) # 5 await redis . pttl ( \"my_key\" ) # 1200 await redis . pttl ( \"this_key_dont_exists\" ) # -2 await redis . pttl ( \"expired_key\" ) # -1 - TTL Returns the Seconds - PTTL Returns the Milliseconds - If the Key doesn't exists it will return -2 - If the Key is expired it will return -1","title":"Get Expire Time"},{"location":"in_memory_backends/api/increase_decrease/","text":"Increase and Decrease You can Increase and Decrease Int Values. await redis . incr ( \"my_key\" ) # my_key + 1 await redis . decr ( \"my_key\" ) # my_key - 1 The Functions will raise a ValueError if the Key is not an Int. If the Key doesn't exists it will set the Key to 1 or -1","title":"Increase and Decrease"},{"location":"in_memory_backends/api/increase_decrease/#increase-and-decrease","text":"You can Increase and Decrease Int Values. await redis . incr ( \"my_key\" ) # my_key + 1 await redis . decr ( \"my_key\" ) # my_key - 1 The Functions will raise a ValueError if the Key is not an Int. If the Key doesn't exists it will set the Key to 1 or -1","title":"Increase and Decrease"},{"location":"in_memory_backends/api/set_get/","text":"Set and Get You can set Values with await redis . set ( \"my_key\" , \"a value\" ) and get them with print ( await redis . get ( \"my_key\" )) # a value GET will return None if the key doesn't exist or is expired. The SET Command has some other Arguments expire_seconds = 5 expire_milliseconds = 555 await redis . set ( key = \"my_key\" , value = \"a value\" , expire = expire_seconds , pexpire = expire_milliseconds , exists = RAMBackend . SET_IF_EXIST ) - key: The Redis Key - value: The Value - expire: The Expire time in Seconds - pexpire: The Expire time in Milliseconds - exists: Exist Conditions","title":"Set and Get"},{"location":"in_memory_backends/api/set_get/#set-and-get","text":"You can set Values with await redis . set ( \"my_key\" , \"a value\" ) and get them with print ( await redis . get ( \"my_key\" )) # a value GET will return None if the key doesn't exist or is expired. The SET Command has some other Arguments expire_seconds = 5 expire_milliseconds = 555 await redis . set ( key = \"my_key\" , value = \"a value\" , expire = expire_seconds , pexpire = expire_milliseconds , exists = RAMBackend . SET_IF_EXIST ) - key: The Redis Key - value: The Value - expire: The Expire time in Seconds - pexpire: The Expire time in Milliseconds - exists: Exist Conditions","title":"Set and Get"},{"location":"in_memory_backends/api/sets/","text":"Sets smembers With smembers you can get all Members of an Set. await redis . smembers ( \"my_set\" ) # {\"item1\", \"item2\"} sadd With sadd you can add an Item to a Set. await redis . sadd ( \"my_set\" , \"item1\" ) srem With srem you can remove an Item from a Set. await redis . srem ( \"my_set\" , \"item1\" )","title":"Sets"},{"location":"in_memory_backends/api/sets/#sets","text":"","title":"Sets"},{"location":"in_memory_backends/api/sets/#smembers","text":"With smembers you can get all Members of an Set. await redis . smembers ( \"my_set\" ) # {\"item1\", \"item2\"}","title":"smembers"},{"location":"in_memory_backends/api/sets/#sadd","text":"With sadd you can add an Item to a Set. await redis . sadd ( \"my_set\" , \"item1\" )","title":"sadd"},{"location":"in_memory_backends/api/sets/#srem","text":"With srem you can remove an Item from a Set. await redis . srem ( \"my_set\" , \"item1\" )","title":"srem"},{"location":"in_memory_backends/in_memory_backend/","text":"In Memory Backend The In Memory Backend is a Redis replacement written in python. It is comparatively slow but if you don't want to have a Redis server, you can use it. To use the In Memory Backend you only have to disable the redis Module.","title":"In Memory Backend"},{"location":"in_memory_backends/in_memory_backend/#in-memory-backend","text":"The In Memory Backend is a Redis replacement written in python. It is comparatively slow but if you don't want to have a Redis server, you can use it. To use the In Memory Backend you only have to disable the redis Module.","title":"In Memory Backend"},{"location":"in_memory_backends/redis/","text":"Introduction This Framework uses Aioredis for Redis.","title":"Introduction"},{"location":"in_memory_backends/redis/#introduction","text":"This Framework uses Aioredis for Redis.","title":"Introduction"},{"location":"in_memory_backends/redis/connection/","text":"Redis Connection You have to init the redis connection with await redis_dependency.init() . Now you can use it as FastAPI Dependency. from aioredis import Redis from fastapi_framework import redis_dependency from fastapi import FastAPI , Depends app = FastAPI () @app . on_event ( \"startup\" ) async def on_startup (): await redis_dependency . init () @app . get ( \"/set/ {key} / {value} \" ) async def test ( key : str , value : str , redis : Redis = Depends ( redis_dependency )): await redis . set ( key , value ) return \"Done\"","title":"Redis Connection"},{"location":"in_memory_backends/redis/connection/#redis-connection","text":"You have to init the redis connection with await redis_dependency.init() . Now you can use it as FastAPI Dependency. from aioredis import Redis from fastapi_framework import redis_dependency from fastapi import FastAPI , Depends app = FastAPI () @app . on_event ( \"startup\" ) async def on_startup (): await redis_dependency . init () @app . get ( \"/set/ {key} / {value} \" ) async def test ( key : str , value : str , redis : Redis = Depends ( redis_dependency )): await redis . set ( key , value ) return \"Done\"","title":"Redis Connection"},{"location":"jwt/","text":"JWT The JWT Module is bases on PyJWT .","title":"JWT"},{"location":"jwt/#jwt","text":"The JWT Module is bases on PyJWT .","title":"JWT"},{"location":"jwt/example/","text":"Example This is a JWT Login/Logout Example with Refresh Tokens. In this example we're using a Fake DB! from typing import Dict , Union from aioredis import Redis from fastapi import FastAPI , Depends , HTTPException from fastapi_framework import ( redis_dependency , get_data , pwd_context , invalidate_refresh_token , check_refresh_token , get_token , generate_tokens , ) app = FastAPI () fake_user_db : Dict [ int , Dict [ str , str ]] = { 0 : { \"id\" : \"0\" , \"username\" : \"test\" , \"password\" : \"$2b$12$vywwXgt8aHzb8PGhTvkZB.y20PzMfBxPr2i9ljr8QFUY6pe7DGWtG\" , # Password is '123' }, 1 : { \"id\" : \"1\" , \"username\" : \"admin\" , \"password\" : \"$2b$12$Uelb/O331cMgXgzdWo6mTO6nM1KS4fULNPzv.lBbEl4QCFQRjNzAi\" , # Password is 'admin' }, } @app . on_event ( \"startup\" ) async def on_startup (): await redis_dependency . init () @app . get ( \"/token\" ) async def token_route ( username : str , password : str , redis : Redis = Depends ( redis_dependency )): user : Union [ Dict [ str , str ], None ] = None for user_db in fake_user_db . values (): if user_db [ \"username\" ] == username : user = user_db . copy () break if user is None or not pwd_context . verify ( password , user [ \"password\" ]): raise HTTPException ( 401 , detail = \"Username or Password is wrong\" ) return await generate_tokens ({ \"user\" : { \"id\" : user [ \"id\" ], \"username\" : user [ \"username\" ]}}, int ( user [ \"id\" ]), redis ) @app . get ( \"/refresh\" ) async def refresh_route ( refresh_token : str , redis : Redis = Depends ( redis_dependency )): data : Dict = {} if not await check_refresh_token ( refresh_token , redis ): raise HTTPException ( 401 , \"Refresh Token Invalid\" ) try : data = await get_data ( refresh_token ) except HTTPException as e : if e . detail == \"Token is expired\" : await invalidate_refresh_token ( refresh_token , redis ) raise e user_id = int ( data [ \"user_id\" ]) user = fake_user_db [ user_id ] await invalidate_refresh_token ( refresh_token , redis ) return await generate_tokens ({ \"user\" : { \"id\" : user [ \"id\" ], \"username\" : user [ \"username\" ]}}, int ( user [ \"id\" ]), redis ) @app . get ( \"/logout\" ) async def logout_route ( refresh_token : str , redis : Redis = Depends ( redis_dependency ), _ = Depends ( get_token )): await invalidate_refresh_token ( refresh_token , redis ) @app . get ( \"/secret\" ) async def secured_route ( data : Dict = Depends ( get_data )): return f 'Hello { data [ \"user\" ][ \"username\" ] } !'","title":"Example"},{"location":"jwt/example/#example","text":"This is a JWT Login/Logout Example with Refresh Tokens. In this example we're using a Fake DB! from typing import Dict , Union from aioredis import Redis from fastapi import FastAPI , Depends , HTTPException from fastapi_framework import ( redis_dependency , get_data , pwd_context , invalidate_refresh_token , check_refresh_token , get_token , generate_tokens , ) app = FastAPI () fake_user_db : Dict [ int , Dict [ str , str ]] = { 0 : { \"id\" : \"0\" , \"username\" : \"test\" , \"password\" : \"$2b$12$vywwXgt8aHzb8PGhTvkZB.y20PzMfBxPr2i9ljr8QFUY6pe7DGWtG\" , # Password is '123' }, 1 : { \"id\" : \"1\" , \"username\" : \"admin\" , \"password\" : \"$2b$12$Uelb/O331cMgXgzdWo6mTO6nM1KS4fULNPzv.lBbEl4QCFQRjNzAi\" , # Password is 'admin' }, } @app . on_event ( \"startup\" ) async def on_startup (): await redis_dependency . init () @app . get ( \"/token\" ) async def token_route ( username : str , password : str , redis : Redis = Depends ( redis_dependency )): user : Union [ Dict [ str , str ], None ] = None for user_db in fake_user_db . values (): if user_db [ \"username\" ] == username : user = user_db . copy () break if user is None or not pwd_context . verify ( password , user [ \"password\" ]): raise HTTPException ( 401 , detail = \"Username or Password is wrong\" ) return await generate_tokens ({ \"user\" : { \"id\" : user [ \"id\" ], \"username\" : user [ \"username\" ]}}, int ( user [ \"id\" ]), redis ) @app . get ( \"/refresh\" ) async def refresh_route ( refresh_token : str , redis : Redis = Depends ( redis_dependency )): data : Dict = {} if not await check_refresh_token ( refresh_token , redis ): raise HTTPException ( 401 , \"Refresh Token Invalid\" ) try : data = await get_data ( refresh_token ) except HTTPException as e : if e . detail == \"Token is expired\" : await invalidate_refresh_token ( refresh_token , redis ) raise e user_id = int ( data [ \"user_id\" ]) user = fake_user_db [ user_id ] await invalidate_refresh_token ( refresh_token , redis ) return await generate_tokens ({ \"user\" : { \"id\" : user [ \"id\" ], \"username\" : user [ \"username\" ]}}, int ( user [ \"id\" ]), redis ) @app . get ( \"/logout\" ) async def logout_route ( refresh_token : str , redis : Redis = Depends ( redis_dependency ), _ = Depends ( get_token )): await invalidate_refresh_token ( refresh_token , redis ) @app . get ( \"/secret\" ) async def secured_route ( data : Dict = Depends ( get_data )): return f 'Hello { data [ \"user\" ][ \"username\" ] } !'","title":"Example"},{"location":"jwt/jwt_tokens/","text":"JWT Tokens There are two types of Tokens: - Access Token - Refresh Token Access Token This token saves Data like User ID , Username and Permission . The User can't modify this without the JWT_SECRET_KEY . The Access Token expires after a short time Refresh Token This Token has a UUID as Data. With this Token you can Refresh your Tokens and get new Tokens. The Refresh Token expires after a long time. It will get Cached in Redis so if you delete it from Redis the Refresh Token is invalid, and the User have to log in again Implementation Access Token from fastapi_framework.jwt_auth import create_access_token from fastapi import FastAPI app = FastAPI () @app . get ( \"/jwt/access_token\" ) async def get_access_token (): return await create_access_token ( { \"user\" : { \"id\" : 5 , \"username\" : \"test\" , \"admin\" : True , } } ) Now you can test the Endpoint, and you'll get a JWT Access Token. To Debug JWT Tokens you can use jwt.io Refresh Tokens from aioredis import Redis from fastapi_framework import redis_dependency from fastapi_framework.jwt_auth import create_refresh_token from fastapi import FastAPI , Depends app = FastAPI () @app . on_event ( \"startup\" ) async def on_startup (): await redis_dependency . init () @app . get ( \"/jwt/refresh_token\" ) async def get_refresh_token ( redis : Redis = Depends ( redis_dependency )): return await create_refresh_token ( 5 , redis ) Now you can test the Endpoint, and you'll get a JWT Refresh Token. The Refresh Token should be in the Redis Cache in the Set refresh_tokens You can check it with the Redis Command smembers refresh_tokens localhost:63792> smembers refresh_tokens 1 ) \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjo1LCJleHAiOjE2MjQ3OTg2MTN9.YVjN2ElK85Mjq9FL0fteZNGpsag78dm2g2EH9gsXsLE\" localhost:63792> Both There is a shorter Way if you want to generate both Tokens e.g. for Login. from aioredis import Redis from fastapi_framework import redis_dependency from fastapi_framework.jwt_auth import generate_tokens from fastapi import FastAPI , Depends app = FastAPI () @app . on_event ( \"startup\" ) async def on_startup (): await redis_dependency . init () @app . get ( \"/jwt/\" ) async def get_tokens ( redis : Redis = Depends ( redis_dependency )): return await generate_tokens ( { \"user\" : { \"id\" : 5 , \"username\" : \"test\" , \"admin\" : True , } }, 5 , redis , ) You'll get a Dict with Data like { \"access_token\" : \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjp7ImlkIjo1LCJ1c2VybmFtZSI6InRlc3QiLCJhZG1pbiI6dHJ1ZX0sImV4cCI6MTYyNDc4NjMwOH0.-7ZdW06DguPb5LMjRym7fDLIUoJeBCa1CohTUNPibpE\" , \"refresh_token\" : \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjo1LCJleHAiOjE2MjQ3OTg5MDh9.vKTwD-pA2S63MPQ3g42a-wIxl7-QcUzSjwtRXI_X_wE\" , \"token_type\" : \"bearer\" } Logout To Logout a use you should invalidate the Refresh Token from aioredis import Redis from fastapi_framework import redis_dependency from fastapi_framework.jwt_auth import invalidate_refresh_token from fastapi import FastAPI , Depends app = FastAPI () @app . on_event ( \"startup\" ) async def on_startup (): await redis_dependency . init () @app . get ( \"/logout/\" ) async def logout ( refresh_token : str , redis : Redis = Depends ( redis_dependency )): await invalidate_refresh_token ( refresh_token , redis ) return None Now you can check out the refresh_tokens Set in Redis. The Refresh Token should be deleted now. localhost:63792> smembers refresh_tokens 1 ) \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjo1LCJleHAiOjE2MjQ3OTg5MDh9.vKTwD-pA2S63MPQ3g42a-wIxl7-QcUzSjwtRXI_X_wE\" localhost:63792> # After the Logout localhost:63792> smembers refresh_tokens ( empty list or set ) localhost:63792> Check Refresh Token In the Refresh Route you have to check if the Token is in the Redis Cache from aioredis import Redis from fastapi_framework import redis_dependency from fastapi_framework.jwt_auth import check_refresh_token from fastapi import FastAPI , Depends app = FastAPI () @app . on_event ( \"startup\" ) async def on_startup (): await redis_dependency . init () @app . get ( \"/check_token/\" ) async def check_token ( refresh_token : str , redis : Redis = Depends ( redis_dependency )): return await check_refresh_token ( refresh_token , redis ) Get Users Token If you want to get the Access Token from the User you can do that with the FastAPI Dependency fastapi_framework.get_token . from fastapi import FastAPI , Depends from fastapi_framework.jwt_auth import get_token app = FastAPI () @app . get ( \"/get_token/\" ) async def check_token ( token : str = Depends ( get_token )): return token Note: To implement the Authentication in the Client send a Authorization Header with Bearer <jwt-access-token-here> Get JWT Tokens Data (as Dependency) To get the Data from the JWT Token you can use the Dependency from typing import Dict from fastapi import FastAPI , Depends from fastapi_framework.jwt_auth import get_data app = FastAPI () @app . get ( \"/get_data/\" ) async def get_data ( data : Dict = Depends ( get_data )): return data Get JWT Token Data (with Token) To get Tokens Data without the Dependency you can use the same function from fastapi import FastAPI from fastapi_framework.jwt_auth import get_data app = FastAPI () @app . get ( \"/get_data/\" ) async def get_data ( token : str ): return await get_data ( token )","title":"JWT Tokens"},{"location":"jwt/jwt_tokens/#jwt-tokens","text":"There are two types of Tokens: - Access Token - Refresh Token","title":"JWT Tokens"},{"location":"jwt/jwt_tokens/#access-token","text":"This token saves Data like User ID , Username and Permission . The User can't modify this without the JWT_SECRET_KEY . The Access Token expires after a short time","title":"Access Token"},{"location":"jwt/jwt_tokens/#refresh-token","text":"This Token has a UUID as Data. With this Token you can Refresh your Tokens and get new Tokens. The Refresh Token expires after a long time. It will get Cached in Redis so if you delete it from Redis the Refresh Token is invalid, and the User have to log in again","title":"Refresh Token"},{"location":"jwt/jwt_tokens/#implementation","text":"","title":"Implementation"},{"location":"jwt/jwt_tokens/#access-token_1","text":"from fastapi_framework.jwt_auth import create_access_token from fastapi import FastAPI app = FastAPI () @app . get ( \"/jwt/access_token\" ) async def get_access_token (): return await create_access_token ( { \"user\" : { \"id\" : 5 , \"username\" : \"test\" , \"admin\" : True , } } ) Now you can test the Endpoint, and you'll get a JWT Access Token. To Debug JWT Tokens you can use jwt.io","title":"Access Token"},{"location":"jwt/jwt_tokens/#refresh-tokens","text":"from aioredis import Redis from fastapi_framework import redis_dependency from fastapi_framework.jwt_auth import create_refresh_token from fastapi import FastAPI , Depends app = FastAPI () @app . on_event ( \"startup\" ) async def on_startup (): await redis_dependency . init () @app . get ( \"/jwt/refresh_token\" ) async def get_refresh_token ( redis : Redis = Depends ( redis_dependency )): return await create_refresh_token ( 5 , redis ) Now you can test the Endpoint, and you'll get a JWT Refresh Token. The Refresh Token should be in the Redis Cache in the Set refresh_tokens You can check it with the Redis Command smembers refresh_tokens localhost:63792> smembers refresh_tokens 1 ) \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjo1LCJleHAiOjE2MjQ3OTg2MTN9.YVjN2ElK85Mjq9FL0fteZNGpsag78dm2g2EH9gsXsLE\" localhost:63792>","title":"Refresh Tokens"},{"location":"jwt/jwt_tokens/#both","text":"There is a shorter Way if you want to generate both Tokens e.g. for Login. from aioredis import Redis from fastapi_framework import redis_dependency from fastapi_framework.jwt_auth import generate_tokens from fastapi import FastAPI , Depends app = FastAPI () @app . on_event ( \"startup\" ) async def on_startup (): await redis_dependency . init () @app . get ( \"/jwt/\" ) async def get_tokens ( redis : Redis = Depends ( redis_dependency )): return await generate_tokens ( { \"user\" : { \"id\" : 5 , \"username\" : \"test\" , \"admin\" : True , } }, 5 , redis , ) You'll get a Dict with Data like { \"access_token\" : \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjp7ImlkIjo1LCJ1c2VybmFtZSI6InRlc3QiLCJhZG1pbiI6dHJ1ZX0sImV4cCI6MTYyNDc4NjMwOH0.-7ZdW06DguPb5LMjRym7fDLIUoJeBCa1CohTUNPibpE\" , \"refresh_token\" : \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjo1LCJleHAiOjE2MjQ3OTg5MDh9.vKTwD-pA2S63MPQ3g42a-wIxl7-QcUzSjwtRXI_X_wE\" , \"token_type\" : \"bearer\" }","title":"Both"},{"location":"jwt/jwt_tokens/#logout","text":"To Logout a use you should invalidate the Refresh Token from aioredis import Redis from fastapi_framework import redis_dependency from fastapi_framework.jwt_auth import invalidate_refresh_token from fastapi import FastAPI , Depends app = FastAPI () @app . on_event ( \"startup\" ) async def on_startup (): await redis_dependency . init () @app . get ( \"/logout/\" ) async def logout ( refresh_token : str , redis : Redis = Depends ( redis_dependency )): await invalidate_refresh_token ( refresh_token , redis ) return None Now you can check out the refresh_tokens Set in Redis. The Refresh Token should be deleted now. localhost:63792> smembers refresh_tokens 1 ) \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjo1LCJleHAiOjE2MjQ3OTg5MDh9.vKTwD-pA2S63MPQ3g42a-wIxl7-QcUzSjwtRXI_X_wE\" localhost:63792> # After the Logout localhost:63792> smembers refresh_tokens ( empty list or set ) localhost:63792>","title":"Logout"},{"location":"jwt/jwt_tokens/#check-refresh-token","text":"In the Refresh Route you have to check if the Token is in the Redis Cache from aioredis import Redis from fastapi_framework import redis_dependency from fastapi_framework.jwt_auth import check_refresh_token from fastapi import FastAPI , Depends app = FastAPI () @app . on_event ( \"startup\" ) async def on_startup (): await redis_dependency . init () @app . get ( \"/check_token/\" ) async def check_token ( refresh_token : str , redis : Redis = Depends ( redis_dependency )): return await check_refresh_token ( refresh_token , redis )","title":"Check Refresh Token"},{"location":"jwt/jwt_tokens/#get-users-token","text":"If you want to get the Access Token from the User you can do that with the FastAPI Dependency fastapi_framework.get_token . from fastapi import FastAPI , Depends from fastapi_framework.jwt_auth import get_token app = FastAPI () @app . get ( \"/get_token/\" ) async def check_token ( token : str = Depends ( get_token )): return token Note: To implement the Authentication in the Client send a Authorization Header with Bearer <jwt-access-token-here>","title":"Get Users Token"},{"location":"jwt/jwt_tokens/#get-jwt-tokens-data-as-dependency","text":"To get the Data from the JWT Token you can use the Dependency from typing import Dict from fastapi import FastAPI , Depends from fastapi_framework.jwt_auth import get_data app = FastAPI () @app . get ( \"/get_data/\" ) async def get_data ( data : Dict = Depends ( get_data )): return data","title":"Get JWT Tokens Data (as Dependency)"},{"location":"jwt/jwt_tokens/#get-jwt-token-data-with-token","text":"To get Tokens Data without the Dependency you can use the same function from fastapi import FastAPI from fastapi_framework.jwt_auth import get_data app = FastAPI () @app . get ( \"/get_data/\" ) async def get_data ( token : str ): return await get_data ( token )","title":"Get JWT Token Data (with Token)"},{"location":"rate_limit/","text":"Rate Limit This module can be used to Limit Requests to Specific Routes like: A Useraccount can access GET /api/v1/user only 10 times per minute","title":"Rate Limit"},{"location":"rate_limit/#rate-limit","text":"This module can be used to Limit Requests to Specific Routes like: A Useraccount can access GET /api/v1/user only 10 times per minute","title":"Rate Limit"},{"location":"rate_limit/example/","text":"Example Example with JWT from fastapi import FastAPI , Depends from fastapi_framework import ( redis_dependency , RateLimiter , RateLimitManager , create_access_token , get_uuid_user_id , get_data , RateLimitTime , ) app = FastAPI () @app . on_event ( \"startup\" ) async def on_startup (): await redis_dependency . init () await RateLimitManager . init ( await redis_dependency (), get_uuid = get_uuid_user_id ) @app . get ( \"/login\" ) async def login_route ( user_id : int ): return await create_access_token ({ \"user_id\" : user_id }) @app . get ( \"/limited\" , dependencies = [ Depends ( RateLimiter ( 2 , RateLimitTime ( seconds = 10 ))), Depends ( get_data )]) async def limited_route (): return f \"Got it\" Example without JWT from fastapi import FastAPI , Depends from fastapi_framework import ( redis_dependency , RateLimiter , RateLimitManager , RateLimitTime ) app = FastAPI () @app . on_event ( \"startup\" ) async def on_startup (): await redis_dependency . init () await RateLimitManager . init ( await redis_dependency ()) @app . get ( \"/limited\" , dependencies = [ Depends ( RateLimiter ( 2 , RateLimitTime ( seconds = 10 )))]) async def limited_route (): return f \"Got it\"","title":"Example"},{"location":"rate_limit/example/#example","text":"","title":"Example"},{"location":"rate_limit/example/#example-with-jwt","text":"from fastapi import FastAPI , Depends from fastapi_framework import ( redis_dependency , RateLimiter , RateLimitManager , create_access_token , get_uuid_user_id , get_data , RateLimitTime , ) app = FastAPI () @app . on_event ( \"startup\" ) async def on_startup (): await redis_dependency . init () await RateLimitManager . init ( await redis_dependency (), get_uuid = get_uuid_user_id ) @app . get ( \"/login\" ) async def login_route ( user_id : int ): return await create_access_token ({ \"user_id\" : user_id }) @app . get ( \"/limited\" , dependencies = [ Depends ( RateLimiter ( 2 , RateLimitTime ( seconds = 10 ))), Depends ( get_data )]) async def limited_route (): return f \"Got it\"","title":"Example with JWT"},{"location":"rate_limit/example/#example-without-jwt","text":"from fastapi import FastAPI , Depends from fastapi_framework import ( redis_dependency , RateLimiter , RateLimitManager , RateLimitTime ) app = FastAPI () @app . on_event ( \"startup\" ) async def on_startup (): await redis_dependency . init () await RateLimitManager . init ( await redis_dependency ()) @app . get ( \"/limited\" , dependencies = [ Depends ( RateLimiter ( 2 , RateLimitTime ( seconds = 10 )))]) async def limited_route (): return f \"Got it\"","title":"Example without JWT"},{"location":"rate_limit/rate_limit_manager/","text":"Rate Limit Manager To use the Raid Limit Feature you have to initialise the Rate Limit Manager. from fastapi_framework import RateLimitManager , redis_dependency await redis_dependency . init () await RateLimitManager . init ( await redis_dependency ()) You can set get_uuid callback get_uuid Setting Callback function that returns a UUID used for Identification. Example: from fastapi import Request async def default_get_uuid ( request : Request ) -> str : \"\"\"Default getter for UUID working with Users IP\"\"\" return f \" { request . client . host } \" callback Callback function that will be called when a User gets Raid Limited and tries it again. Example: from fastapi import HTTPException from typing import Dict async def default_callback ( headers : Dict ): \"\"\"Default Error Callback when get Raid Limited\"\"\" raise HTTPException ( 429 , detail = \"Too Many Requests\" , headers = headers ) You should return the Headers to the users","title":"Rate Limit Manager"},{"location":"rate_limit/rate_limit_manager/#rate-limit-manager","text":"To use the Raid Limit Feature you have to initialise the Rate Limit Manager. from fastapi_framework import RateLimitManager , redis_dependency await redis_dependency . init () await RateLimitManager . init ( await redis_dependency ()) You can set get_uuid callback","title":"Rate Limit Manager"},{"location":"rate_limit/rate_limit_manager/#get_uuid-setting","text":"Callback function that returns a UUID used for Identification. Example: from fastapi import Request async def default_get_uuid ( request : Request ) -> str : \"\"\"Default getter for UUID working with Users IP\"\"\" return f \" { request . client . host } \"","title":"get_uuid Setting"},{"location":"rate_limit/rate_limit_manager/#callback","text":"Callback function that will be called when a User gets Raid Limited and tries it again. Example: from fastapi import HTTPException from typing import Dict async def default_callback ( headers : Dict ): \"\"\"Default Error Callback when get Raid Limited\"\"\" raise HTTPException ( 429 , detail = \"Too Many Requests\" , headers = headers ) You should return the Headers to the users","title":"callback"}]}